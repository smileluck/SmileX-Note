##### <font size="4" color="red">01. Redis中Sdown和Odown转换机制</font>

**`sdown`主观宕机：**一个哨兵如果自己觉得一个`master`宕机了，那么就是主观宕机。

**`odown`客观宕机：**如果`quorum`数量的哨兵都觉得`master`宕机了，那么久是客观宕机。

`sdown`达成条件很简单，如果一个哨兵`ping`一个`master`超过了`is-master-down-after-milliseconds`指定的毫秒数之后，就主观认为`master`宕机了，如果一个哨兵在指定时间内，收到了`quorum`数量的其他哨兵也认为`master`是`sdown`，那么就认为是`odown`客观宕机。

***

##### <font size="4" color="red">02. Redis中哨兵集群的自动发现机制</font>

​		哨兵互相之间的发现，是通过`Redis`的 `pub/sub` 系统实现的，每个哨兵都会往 `__sentinel__:hello` 这个`channel`里发送一个消息，这时候所有其他哨兵都可以消费到这个消息，并感知到其他的哨兵的存在。

每隔两秒钟，每个哨兵都会往自己监控的某个`master+slaves`对应的 `__sentinel__:hello channel`里发送一个消息，内容是自己的`host`、`ip`和`runid`还有对这个`master` 的监控配置。

​		每个哨兵也会去监听自己监控的每个`master+slaves`对应的 `__sentinel__:hello` channel，然后去感知到同样在监听这个`master+slaves`的其他哨兵的存在。每个哨兵还会跟其他哨兵交换对 `master` 的监控配置，互相进行监控配置的同步。

***

##### <font size="4" color="red">03. Redis中Slave自动纠正</font>

​		哨兵会负责自动纠正`slave`的一些配置，比如`slave`如果要成为潜在的`master`候选人，哨兵会确保`slave`复制现有`master`的数据；如果`slave`连接到了一个错误的`master `上，比如故障转移之后，那么哨兵会确保它们连接到正确的 `master`上。

***

##### <font size="4" color="red">04. Redis中quorum和majroity主备切换</font>

```
    每次一个哨兵要做主备切换，首先需要quorum数量的哨兵认为odown，然后选举出一个哨兵来做切换，这个哨兵还需要得到majority哨兵的授权，才能正式执行切换。如果 quorum < majority，比如 5 个哨兵，majority就是3，quorum设置为 2，那么就 3 个哨兵授权就可以执行切换。但是如果 quorum >= majority，那么必须quorum数量的哨兵都授权，比如 5 个哨兵，quorum是5，那么必须 5 个哨兵都同意授权，才能执行切换。
```

***

##### <font size="4" color="red">05. Redis中Slave和Master选举算法</font>

```
(1) 跟master断开连接的时长
(2) slave优先级
(3) 复制offset
(4) run id
	按照slave优先级进行排序，slave priority 越低，优先级就越高。如果 slave priority 相同，那么看 replica offset，哪个 slave 复制了越多的数据，offset 越靠后，优先级就越高。如果上面两个条件都相同，那么选择一个 run id 比较小的那个 slave。
```

***

##### <font size="4" color="red">06. 余弦定理求相似度</font>

| 姓名         | 身高（厘米） | 金钱(元） |
| ------------ | ------------ | --------- |
| 胡八一       | 185          | 532       |
| 二龙湖浩哥   | 179          | 550       |
| 喜洋洋       | 156          | 143       |
| 东北酒神九哥 | 210          | 340       |

![](./img/img(04)/06-01.jpg)

可以看到`肖能逗`与二龙湖浩哥的信息是最贴近的，因为他们的夹角小。所以一定推荐的就是`二龙湖浩哥`了。

整个过程是：

利用余弦定理去计算`肖能逗`与`其余所有人的值`，这个值越小，说明越相似，相似度越高。

这就得出了我们可以求`N`个数据维度的余弦定理公式。

我们只需要套进去这个公式，就可以求出我们想要的相似度对比数据（也就是夹角的数据）。
$$
\cos(\Theta) = \frac{\sum_{n=1}^{n}(x_i{\times}y_i)}{\sqrt{{\sum_{n=1}^{n}(x_i)^2}\times{\sum_{n=1}^{n}(y_i)^2}}}
$$

```java
public class test {

    private static Double compare(int[] o1, int[] o2) {

        //分子求和
        Double fenzi = 0.0 ;

        for (int i = 0; i < o1.length; i++) {
            fenzi += o1[i]*o2[i];
        }

        //分母第一部分
        Double fenmu1 = 0.0;
        for (int i = 0; i < o1.length; i++) {
            fenmu1 += o1[i] * o1[i];
        }

        fenmu1 = Math.sqrt(fenmu1);

        //分母第二部分
        Double fenmu2 = 0.0;
        for (int i = 0; i < o2.length; i++) {
            fenmu2 += o2[i] * o2[i];
        }
        fenmu2 = Math.sqrt(fenmu2);

        return fenzi / (fenmu1 * fenmu2);
    }

    public static void main(String[] args) throws Exception {
        int x[] = {1,2,3,4,5,6,7};
        int y[] = {1,2,3,4,5,6,7};
        int c[] = {1,5,6,7,8,9,0};
        System.out.println(compare(x,y));
        System.out.println(compare(x,c));
    }

}
```

***

##### <font size="4" color="red">07. Paxos算法</font>

```
Proposer ：提议者
Acceptor：决策者
Client：产生议题者
Learner：最终决策学习者
```

提议者和决策者是很重要的，其他的2个角色在整个算法中应该算做打酱油的，`Proposer`就像`Client`的使者，由`Proposer`使者拿着`Client`的议题去向`Acceptor`提议，让`Acceptor`来决策。这里上面出现了个新名词：最终决策。现在来系统的介绍一下`paxos`算法中所有的行为：

(1) `Proposer`提出议题

(2) `Acceptor`初步接受 或者`Acceptor`初步不接受

(3) 如果上一步`Acceptor`初步接受则`Proposer`再次向`Acceptor`确认是否最终接受

(4) `Acceptor`最终接受 或者`Acceptor`最终不接受

![](./img/img(04)/07-01.jpg)

```
	为什么需要3个Acceptor？因为Acceptor必须是最少大于等于3个，并且必须是奇数个，因为要形成多数派嘛，如果是偶数个，比如4个，2个接受2个不接受，各执己见，没法搞下去了。
	为什么是3个Proposer？ 其实无所谓是多少个了，1~n 都可以的；如果是1个proposer，毫无竞争压力，很顺利的完成2阶段提交，Acceptor们最终批准了事。如果是多个proposer就比较复杂了
	zookeeper常常用来做分布式事务锁。Zookeeper所使用的zad协议也是类似paxos协议的。所有分布式自协商一致性算法都是paxos算法的简化或者变种。Client是使用zookeeper服务的机器，Zookeeper自身包含了Acceptor, Proposer, Learner。Zookeeper领导选举就是paxos过程，还有Client对Zookeeper写Znode时，也是要进行Paxos过程的，因为不同Client可能连接不同的Zookeeper服务器来写Znode，到底哪个Client才能写成功？需要依靠Zookeeper的paxos保证一致性，写成功Znode的Client自然就是被最终接受了，Znode包含了写入Client的IP与端口，其他的Client也可以读取到这个Znode来进行Learner。也就是说在Zookeeper自身包含了Learner(因为Zookeeper为了保证自身的一致性而会进行领导选举，所以需要有Learner的内部机制，多个Zookeeper服务器之间需要知道现在谁是领导了)，Client端也可以Learner，Learner是广义的。
```

***

##### <font size="4" color="red">08. Redis相比Memcached优势</font>

```
(1) Memcached 所有的值均是简单的字符串，Redis 作为其替代者，支持更为丰富的数据类
(2) Redis 的速度比 Memcached 快很多
(3) Redis 可以持久化其数据
```

***

##### <font size="4" color="red">09. Redis删除策略</font>

**定时删除：**在设置键的过期时间的同时，创建一个定时器 timer。让定时器在键的过期时间来临时，立即执行对键的删除操作。

**惰性删除：**放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键;如果没有过期，就返回该键。

**定期删除：**每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。

***

##### <font size="4" color="red">10. Redis从1亿数据固定前缀开头键值</font>

​		使用`keys`指令可以扫出指定模式的`key`列表。`Redis`的单线程的。`keys`指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用`scan`指令，`scan`指令可以无阻塞地提取出指定模式的`key`列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用`keys`指令长。

***

##### <font size="4" color="red">11. 如何保证Redis中的数据都是热点数据</font>

​		`Redis`内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。

***

##### <font size="4" color="red">12. Redis事务相关的命令</font>

```
multi、exec、discard、watch
```

***

##### <font size="4" color="red">13. Rsync和Serync同步原理</font>

````
(1)用户实时的往sersync服务器上写入更新文件数据,此时需要在源数据服务器上配置sersync服务；
(2) 在另一台服务器开启rsync守护进程服务，以同步拉取来自sersync服务器上的数据；
	通过rsync的守护进程服务后可以发现，实际上sersync就是监控本地的数据写入或更新事件；然后，在调用rsync客户端的命令，将写入或更新事件对应的文件通过rsync推送到目标服务器。
````

***

##### <font size="4" color="red">14. Mysql逻辑架构</font>

![](./img/img(04)/14-01.jpg)

```
1.第一层，主要是不同客户端的连接
2.第二层，主要是处理客户端的连接
3.第三层，处理客户端的sql语句
4.第四层，存储引擎真实的执行sql语句
```

***

##### <font size="4" color="red">15. IFPS与Http协议区别</font>

**`IPFS`星际文件传输系统**：它是一种内容可寻址、版本化、点对点超媒体的分布式存储、传输协议。`IPFS`将很多种技术（`p2p`网络技术、`bittorrent`传输技术、`git`版本控制，自证明文件系统的数据传输协议等等）加以结合，并在这些技术上改进创新，集成了一个去中心化的`IPFS`网络。

```
1.http属于中心化的，所有流量直接存储在中心化的服务器上，承载的工作量极大，容易造成系统拥堵和崩溃，http还容易遭受DDOS攻击；IPFS的存储方式是去中心化，一个文件可以分为多分小型文件碎片，黑客无法攻击，文件不易丢失，安全有保障。2、效率：http依赖中心化服务网络，服务器容易被关闭，服务器上文件也容易被删除篡改，服务器需要24小时开机;IPFS采用P2P网络拓扑，全网域的计算机都可以成为存储节点，就近分布式存储大大提高了网络效率。
2.http属于中心化的，所有流量直接存储在中心化的服务器上，承载的工作量极大，容易造成系统拥堵和崩溃，http还容易遭受DDOS攻击；IPFS的存储方式是去中心化，一个文件可以分为多分小型文件碎片，黑客无法攻击，文件不易丢失，安全有保障。2、效率：http依赖中心化服务网络，服务器容易被关闭，服务器上文件也容易被删除篡改，服务器需要24小时开机;IPFS采用P2P网络拓扑，全网域的计算机都可以成为存储节点，就近分布式存储大大提高了网络效率。
```

***

##### <font size="4" color="red">16. Mysql为什么选用B+树做索引</font>

**索引：**所谓的索引，就是帮助`MySQL`高效获取数据的排好序的数据结构。因此，根据索引的定义，构建索引其实就是数据排序的过程。

**B树结构：**

​		叶节点具有相同的深度，叶节点的指针为空，所有索引的元素不重复，节点中的数据索引从左到右递增排序。

![](./img/img(04)/16-01.jpg)

**优点**：在二叉平衡树的基础上，使加载一次节点，可以加载更多路径数据，同时把查询范围缩减到更小。

**缺点**：业务数据的大小可能远远超过了索引数据的大小，每次为了查找对比计算，需要把数据加载到内存以及`CPU`高速缓存中时，都要把索引数据和无关的业务数据全部查出来。本来一次就可以把所有索引数据加载进来，现在却要多次才能加载完。如果所对比的节点不是所查的数据，那么这些加载进内存的业务数据就毫无用处，全部抛弃。

**B+树结构：**

​		非叶子节点不存储数据，只存储索引(冗余的)，可以放更多的索引，叶子节点包含索引所有字段，叶子节点用指针链接，提高区间访问性能（可以极大减少随机`I/O`，进而提高性能）。

![](./img/img(04)/16-02.jpg)

​		`B+`树中，非叶子节点只保存索引数据，叶子节点保存索引数据与业务数据。这样即保证了叶子节点的简约干净，数据量大大减小，又保证了最终能查到对应的业务数。既提高了单次`I/O` 数据的有效性，又减少了`I/O`次数，还实现了业务。

***

##### <font size="4" color="red">17. OSI七层模型</font>

| `OSI`七层网络模型         | `TCP/IP`四层概念模型                       | 对应网络协议                                        |
| ------------------------- | ------------------------------------------ | --------------------------------------------------- |
| 应用层（`Application`）   | 应用层                                     | `HTTP`、`TFTP`, `FTP`, `NFS`, `WAIS`、`SMTP`        |
| 表示层（`Presentation`）  | `Telnet`, `Rlogin`, `SNMP`, `Gopher`       |                                                     |
| 会话层（`Session`）       | `SMTP`, `DNS`                              |                                                     |
| 传输层（`Transport`）     | 传输层                                     | `TCP`, `UDP`                                        |
| 网络层（`Network`）       | 网络层                                     | `IP`, `ICMP`, `ARP,` `RARP`, `AKP`,` UUCP`          |
| 数据链路层（`Data Link`） | 数据链路层                                 | `FDDI`, `Ethernet`, `Arpanet`, `PDN`, `SLIP`, `PPP` |
| 物理层（`Physical`）      | `IEEE 802.1A`,` IEEE 802.2`到`IEEE 802.11` |                                                     |

![](./img/img(04)/17-01.png)

***

##### <font size="4" color="red">18. 缓存失效策略以及算法比较</font>

`FIFO`算法：先进先出。判断被存储的时间，离目前最远的数据优先被淘汰。
`LRU`算法：最近最少使用。判断最近被使用的时间，目前最远的数据优先被淘汰。
`LFU`算法：最不经常使用。在一段时间内，数据被使用次数最少的，优先被淘汰。

***

##### <font size="4" color="red">19. SpringBoot常用注解</font>

1.`Configuration`和`@ComponentScan`注解

​		`@Configuration`和`@ComponentScan`注解使`Spring`能够创建和配置应用程序的`bean`和组件，将实际业务逻辑代码与应用程序连接分离。

2.`@Controller`注解

​		将类标记为`web`控制器，能够处理`HTTP`请求。`Spring`将查看用`@Controller`注解标记的类的方法，并建立路由表，以了解哪些方法服务于哪些端点。

3.`@RespnseBody`注解

​		它使`Spring`将方法的返回值绑定到`HTTP`响应体。在构建`JSON`端点

4.`@RestController`注解

​		这是`@Controller`和`@ResponseBody`的一种方便语法。这意味着标记类中的所有操作方法都将返回`JSON`响应

5.`@RequestMapping`注解

​		 这个注解指定控制器中负责将`HTTP`请求提供给给定路径的方法。`Spring`将处理如何实现的实现细节。只需在注解上指定路径值，`Spring`就会将请求路由到正确的操作方法中。

***

##### <font size="4" color="red">20. Redis缓存淘汰策略</font>

```
noeviction：返回错误
allkeys-lru：尝试回收最少使用的数据（LRU）
volatile-lru：尝试回收最少使用的数据（LRU），但只限于设置了过期时间的数据
allkeys-random：尝试随机回收部分数据
volatile-random：尝试随机回收部分数据，但只限于设置了过期时间的数据
volatile-ttl：尝试回收设置了过期时间的数据，优先回收存活时间（TTL）较短的数据。
```

​		`Redis`通常用作缓存而不是真正的数据库，所以`noeviction`通常不选择。`allkeys-random`及`volatile-random`过于随机，`volatile-ttl`则时间成本相对较高，所以通常来说是在`allkeys-lru`及`volatile-lru`中选择一个。

***

##### <font size="4" color="red">21. MySql删除原理</font>

**1.空间复用**

​		`MySql innodb`存储引擎中，当执行`Delete`的时候，数据并没有真正被删除，只是对应数据的删除标识`deleteMark`被打开，每次执行查询时，如果发现数据存在但是`deleteMark`被打开的话，查询结果依然返回为空。

​		`MySql`更新数据的时候将更新前的数据先写入`undo log`中，这样当需要回滚的时候，只需要顺着`undo log`找到历史数据即可。`undo log`与原始数据之间是用指针链接起来的，即每条数据都有个回滚指针指向`undo log`。如果`InnoDB`在删除数据的时候，真的是把数据从磁盘上擦除，那么这时候：别的事务通过`undo log`是无法找到原始数据可重复读这个特性会被破坏。

​		`Mysql`里面有个`purge`线程，它的工作中有一项任务就是专门检查这些有`deleteMark`的数据，当有`deleteMark`的数据如果没有被其他事务引用时，那么会被标记成可复用，因为叶子节点数据是有序的原因，这样当下次有同样位置的数据插入时，可以直接复用这块磁盘空间。当整个页都可以复用的时候，也不会把它还回去，会把可复用的页留下来，当下次需要新页时可以直接使用，从而减少频繁的页申请。

**2.基于页的存储方式**

​		`Mysql`数据是存储在磁盘上的，当发生随机`IO`的时候。这里简单解释下什么叫`IO`，以机械磁盘为例，我们最终的数据都是落在磁盘的一个一个扇区上的，当一个扇区写满了，就得换下一个扇区，这时就要通过盘片的转动找到目标扇区，这是物理运动。如果要写入的下一个扇区和当前的扇区是紧挨着的，这叫顺序`IO`，如果要写入的扇区和当前的扇区中间隔了几个扇区，这叫随机`IO`，很明显随机`IO`需要更长的转动时间。所以查询一个数据的时候，减少`IO`是非常关键的，特别是随机`IO`。

​		为了减少磁盘`IO`，`Mysql`采用`B+`树的索引结构来组织数据，`B+`树的特点是矮胖，一般树的高度就代表了`IO`的次数，越矮的话，树的高度越低，那么对应的`IO`次数就越少，还有一点需要知道的是数据最终都在叶子节点上，所以在`B+`树上搜索的时候，一定是要检索到最后一层叶子节点上，这是一种稳定性的表现。

​		树的高度等于`IO`的次数，这其实不是很准确，树的根节点一定是在内存里的，那么对于一颗高度为`3`的数据，只用`2`次`IO`即可，这其实可以理解，毕竟根节点只占用一页的空间，一页才`16K`，放在内存里绰绰有余。但有时候树的第二层也可以放在内存里，假设现在主键是`bigint`，`bigint`我们知道占用`8`个字节，对于一个索引来说除了类型本身占用空间之外，还有一个指针，这个指针占用`6`个字节，那么对于根节点来说它大概能存`16K/(8+6)B = 1170`个数据，每个数据都可以指向一页（也就是它的下一层），这样整个树的第二层大概占用`1170*16K = 18M`的空间，这也不是一个很大的数字，对于机器的内存来说，几乎也是沧海一粟，所以第二层往往也在内存里，所以最终在`B+`树上检索数据所消耗的`IO`应该比理论的要低。

​		检索一条数据的快慢，主要受树的高度影响的，这和数据表的大小并没有太大的关系，现实中有人可能在数据表达到百万级别的时就考虑分表，个人认为这有点低估`B+`树的能力了。还是以`bigint`类型的主键索引为例，假设一行数据占用`1K`（理论上已经足够大了），那么一页可以存下 `16K/1K=16` 条数据，对于一颗高度为`3`的`B+`树来说，它可以存下 `1170\1170\16=21902400` 的数据，将近`2`千万，如果你的数据行占用的空间更小，就可以存下更多的数据，所以只是简单的根据数据行数来判断是否需要分表不是那么的合理。

​		删除的数据不会被真的删除，只是打上个`deleteMark`的标识，然后会被复用，但是如果一直没被复用，那么空间不就是白白的浪费了，更糟糕的是，如果删除的很多数据空间都没有被复用，就会造成页空间存在大量的碎片，为了解决这种情况，`Mysql`内部有个叫页合并的功能，简单理解就是页`A`现在有很多可以被复用的空间，它的邻居页`B`也有很多可以复用的空间，此时页`A`就可以和页`B`合并，如果合并后能省出来一页，那么多出来的一页就可以被下次使用，从而达到页最大利用的效果。

![](./img/img(04)/21-01.jpg)

​		合并的关键需要当前页的前一页或者后一页也有大量的碎片空间，合并的动作可以简单理解就是把别的页的数据移动过来，如果两个页`pageA`和`pageB`都只有少量的可复用空间，那么合并后，即使`pageA`可以填满，但是另一个页`Page`也还是有碎片空间的，并且碎片更大，这时候数据移动的开销可能要大于存储的开销，得不偿失。而且还会有个严重的问题，`pageB`可能会和`pageC`合并，那么`pageC`的碎片更大，这样的话似乎是个无底洞，导致很多页都在移动数据。因此一个合理的合并条件很关键，`InnoDB`中何时合并受`MERGE_THRESHOLD`这个参数影响，它的默认值是`50%`，`50%`的意图很明显，两个`50%`就可以省出一个页。`pageA`已经有`50%`的数据被删除了，它的邻居`pageB`只使用了不到`50%`的数据，这时候会将`pageB`的数据移动到`pageA`上，那么整个`pageB`就是空页了，可以提供给别的数据使用。这里需要知道的是除了删除会触发页合并外，更新可能也会触发页合并。合并页是提升页的利用率的方式，但是有时候我们又不得不分裂页，我们知道叶子节点的页之间是用双向链表串接起来的，并且页与页之间的数据是有序的。

![](./img/img(04)/21-02.jpg)

​		当我们要插入`5`这条数据，按道理应该尝试放在`pageA`里面，但是`pageA`目前没有足够的空间来存放一条数据，于是尝试找到`pageA`的相邻页`pageB`，但是此时很不幸的是`pageB`也没有足够的空间来存放一条数据，由于要求数据的连续性，数据5必须在数据4和数据6之间，那么只能新建一个页，新建一个页后，会尝试从`pageA`移动一部分数据到新的页上，并且会重新组织页与页之间的关系，即在`pageA`和`pageB`之间会隔一道新页`pageC`。

![](./img/img(04)/21-03.jpg)

页分裂会造成页的利用率降低，造成页分裂的原因有很多，比如：

```
1.离散的插入，导致数据不连续。
2.把记录更新成一个更大记录，导致空间不够用
```

> **注：**不管是页的合并还是页的分裂，都是相对耗时的操作，除了移动数据的开销外，`InnoDB`也会在索引树上加锁。

**3.手动建表**

​		页的合并和分裂主要是在插入、删除或更新的时候，并且正好满足某些条件才发生的，那如果这些条件一直不满足，碎片就无法得到清理。这个时候表明明没多少数据，为什么还占用这么大空间，重建索引可以让数据更加紧凑，页的利用率达到更高。如果要重建的索引是普通索引，使用这种方式还好，需要注意的是假如你的业务`TPS`很大，建议在业务低峰期执行，因为虽然`Mysql`支持`online ddl`，但是重建索引的过程还是很耗`cpu`和`io`资源的。

​		如果主键索引设置的是自增长，是不支持`drop`的。其次如果你的主键没设置成自增长，直接`drop`也不是我们想象的那样，知道普通索引除了记录本身的索引字段外，还会记录主键的值，如果`drop`是直接删除索引，那么通过普通引将找不到对应的行记录，所以`InnoDB`是要求必须有主键索引的，这时`InnoDB`会尝试去表中找个唯一索引来当主键，如果没有唯一索引，那就自动创建一个默认的主键索引`rowid`，当新的主键索引建立好之后，还要去修改相关的普通索引让其存储新的主键，但是如果按照这种方法来修改的话，开销会很大，特别是普通索引很多的情况下，于是`InnoDB`干脆选择重建表。对于紧接着执行的`add index`操作，同样也会发生主键索引的变更，所以也会选择重建表，最终可以发现在主键索引上的`drop`和`add`其实干了一样的事情。

**4.重建表不一定会收缩空间**

​		重建表的过程中，`InnoDB`不会让重建后的页充满数据，会预留个`1/16`的空间，如果不预留，选择占满整个页，这时候去更新一条需要更大空间的老数据，就会需要新的页，写入新的页后，往往又会造成碎片，所以提前预留一点空间是有用的。但是因为这个预留操作，某些情况下会导致重建后的表空间反而会变大。在第一次重建表后，因为新的插入导致用掉了预留空间的一部分（这里需要注意的是预留空间没用完，还剩一部分），但是没有用到新的页，所以整体的空间没有变化，这时候如果再次重建表，就会因为要预留`1/16`，导致申请的新的页，那么空间就会变大。

***

##### <font size="4" color="red">22. Kubernetes架构原理</font>

​		`Kubernetes`最初源于谷歌内部的`Borg`，提供了面向应用的容器集群部署和管理系统。`Kubernetes`的目标旨在消除编排物理/虚拟计算，网络和存储基础设施的负担，并使应用程序运营商和开发人员完全将重点放在以容器为中心的原语上进行自助运营。

​		`Kubernetes`基于容器技术，`Kubernetes`可以方便的进行集群应用的部署、扩容、缩容、自愈机制、服务发现、负载均衡、日志、监控等功能，大大减少日常运维的工作量。`Kubernetes`所有的操作都可以通过`Kubernetes API`来进行，通过`API`来操作`Kubernetes`中的对象，包括`Pod`、`Service`、`Volume`、`Namespace`等等。

![](./img/img(04)/22-01.jpg)

![](./img/img(04)/22-02.jpg)

![](./img/img(04)/22-03.jpg)

`Kubernetes`主要由以下几个核心组件组成：

```
1.etcd保存了整个集群的状态；
2.apiserver提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制；
3.controller manager负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；
4.scheduler负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上；
5.kubelet负责维护容器的生命周期，同时也负责Volume(CVI)和网络(CNI)的管理；
6.Container runtime负责镜像管理以及Pod和容器的真正运行(CRI)；
7.kube-proxy负责为Service提供cluster内部的服务发现和负载均衡；
```

除了核心组件，还有一些推荐的`Add-ons`：

```
1.kube-dns负责为整个集群提供DNS服务
2.Ingress Controller为服务提供外网入口
3.Heapster提供资源监控
4.Dashboard提供GUI
5.Federation提供跨可用区的集群
6.Fluentd-elasticsearch提供集群日志采集、存储与查询
```

​		`API`对象是`K8s`集群中的管理操作单元。`K8s`集群系统每支持一项新功能，引入一项新技术，一定会新引入对应的`API`对象，支持对该功能的管理操作。例如副本集`Replica Set`对应的`API`对象是`RS`。

​		每个`API`对象都有`3`大类属性：元数据`metadata`、规范`spec`和状态`status`。元数据是用来标识`API`对象的，每个对象都至少有`3`个元数据：`namespace`，`name`和`uid`；除此以外还有各种各样的标签`labels`用来标识和匹配不同的对象，例如用户可以用标签`env`来标识区分不同的服务部署环境，分别用`env=dev`、`env=testing`、`env=production`来标识开发、测试、生产的不同服务。

**1.`Pod`对象**

​		`Pod`是`Kubernetes`的最小工作单元。每个`Pod`包含一个或多个容器。`Pod`中的容器会作为一个整体被`Master`调度到一个`Node`上运行。

`Kubernetes`引入`Pod`主要基于下面两个目的：

```
1.可管理性
	有些容器天生就是需要紧密联系，一起工作。Pod提供了比容器更高层次的抽象，将它们封装到一个部署单元中。Kubernetes以Pod为最小单位进行调度、扩展、共享资源、管理生命周期。
2.通信和资源共享
	Pod中的所有容器使用同一个网络namespace,即相同的IP地址和Port空间。它们可以直接用 localhost通信。同样的，这些容器可以共享存储，当Kubernetes挂载volume到Pod，本质上是将 volume挂载到Pod中的每一个容器。
```

**2.`Controller`对象**

​		`Kubernetes`通常不会直接创建`Pod`，而是通过`Controller`来管理`Pod`的。`Controller`中定义了`Pod`的部署特性，比如有几个副本，在什么样的 `Node`上运行等。为了满足不同的业务场景，`Kubernetes`提供了多种`Controller`，包括`Deployment`、`ReplicaSet`、`DaemonSet`、`StatefuleSet`、`Job`等。

**3.`Deployment`对象**

​		`Deployment`是最常用的`Controller`，比如前面在线教程中就是通过创建`Deployment`来部署应用的。`Deployment`可以管理`Pod`的多个副本，并确保`Pod`按照期望的状态运行。

**4.`ReplicaSet`对象**

​		`ReplicaSet`实现了`Pod`的多副本管理。使用`Deployment`时会自动创建`ReplicaSet`，也就是说 `Deployment `是通过`ReplicaSet`来管理`Pod`的多个副本，我们通常不需要直接使用`ReplicaSet`。

**5.`DaemonSet`对象**

​		`DaemonSet`用于每个`Node`最多只运行一个`Pod`副本的场景。正如其名称所揭示的，`DaemonSet`通常用于运行`daemon`。

**6.`StatefuleSet`对象**

​		`StatefuleSet`能够保证`Pod`的每个副本在整个生命周期中名称是不变的。而其他`Controller`不提供这个功能，当某个`Pod`发生故障需要删除并重新启动时，`Pod`的名称会发生变化。同时 `StatefuleSet`会保证副本按照固定的顺序启动、更新或者删除。

**7.`Job`对象**

​		`Job`用于运行结束就删除的应用。而其他`Controller`中的`Pod`通常是长期持续运行。

**8.`Service`对象**

​		`RC`、`RS`和`Deployment`只是保证了支撑服务的微服务`Pod`的数量，但是没有解决如何访问这些服务的问题。一个`Pod`只是一个运行服务的实例，随时可能在一个节点上停止，在另一个节点以一个新的`IP`启动一个新的`Pod`，因此不能以确定的`IP`和端口号提供服务。要稳定地提供服务需要服务发现和负载均衡能力。服务发现完成的工作，是针对客户端访问的服务，找到对应的的后端服务实例。在`K8s`集群中，客户端需要访问的服务就是`Service`对象。每个`Service`对应一个集群内部有效的虚拟`IP`，集群内部通过虚拟`IP`访问一个服务。在`K8s`集群中微服务的负载均衡是由`Kube-proxy`实现的。`Kube-proxy`是`K8s`集群内部的负载均衡器。它是一个分布式代理服务器，在`K8s`的每个节点上都有一个；这一设计体现了它的伸缩性优势，需要访问服务的节点越多，提供负载均衡能力的`Kube-proxy`就越多，高可用节点也随之增多。

**9.`Namespace`对象**

​		名字空间为`K8s`集群提供虚拟的隔离作用，`K8s`集群初始有两个名字空间，分别是默认名字空间`default`和系统名字空间`kube-system`，除此以外，管理员可以可以创建新的名字空间满足需要。

**`Kubernetes`分层架构：**

`Kubernetes`设计理念和功能其实就是一个类似`Linux`的分层架构。

![](./img/img(04)/22-04.jpg)

***

##### <font size="4" color="red">23. @Transactional失效场景</font>

**1.代理不生效**

(1) 将注解标注在接口方法上

​		`@Transactional`是支持标注在方法与类上的。一旦标注在接口上，对应接口实现类的代理方式如果是`CGLIB`，将通过生成子类的方式生成目标类的代理，将无法解析到`@Transactional`，从而事务失效。

(2) 被`final`、`static`关键字修饰的类或方法

​		`CGLIB`是通过生成目标类子类的方式生成代理类的，被`final`、`static`修饰后，无法继承父类与父类的方法。

(3) 类方法内部调用

​		事务的管理是通过代理执行的方式生效的，如果是方法内部调用，将不会走代理逻辑，也就调用不到了。

**2.框架或底层不支持的功能**

(1) 不支持非`public`修饰的方法进行事务管理。

(2) 多线程调用

(3) 数据库本身不支持事务

​		比如`Mysql`的`Myisam`存储引擎是不支持事务的，只有`innodb`存储引擎才支持。这个问题出现的概率极其小，因为`Mysql5`之后默认情况下是使用`innodb`存储引擎了。

***



