##### <font size="4" color="red">01. Http请求方式</font>

| 请求方式  | 描述                                                  |
| --------- | ----------------------------------------------------- |
| `get`     | 请求指定页面信息                                      |
| `head`    | 类似于get请求                                         |
| `post`    | 向指定资源提交数据进行处理请求                        |
| `put`     | 从客户端向服务器传递的数据取代指定的文档内容          |
| `delete`  | 请求服务器删除指定的页面                              |
| `connect` | http1.1协议中预留给能够将连接改为管道方式的代理服务器 |
| `option`  | 允许客户端查看服务器性能                              |
| `trace`   | 回显服务器收到的请求                                  |

***

##### <font size="4" color="red">02. Springboot微服务优点</font>

(1) 独立开发

(2) 独立部署

(3) 易扩展、易复用

***

##### <font size="4" color="red">03. Java基本数据类型</font>

| 数据类型 | 描述 |
| -------- | ---- |
| `byte` | 位 |
|`short`|短整数|
|`int`|整数|
|`long`|长整数|
|`float`|单精度|
|`double`|双精度|
|`char`|字符|
|`boolean`|布尔值|

***

##### <font size="4" color="red">04. Java接口和抽象类的区别</font>

**相同点：**

(1)都不能被实例化
(2) 接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。

**不同点：**

(1) 接口只有定义，不能有方法的实现，`java 1.8中可以定义default方法体`，而抽象类可以有定义与实现，方法可在抽象类中实现。
(2) 实现接口的关键字为`implements`，继承抽象类的关键字为`extends`。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。
(3) 接口强调特定功能的实现，而抽象类强调所属关系。
(4) 接口成员变量默认为`public static final`，必须赋初值，不能被修改；其所有的成员方法都是`public`、`abstract`的。抽象类中成员变量默认`default`，可在子类中被重新定义，也可被重新赋值；抽象方法被`abstract`修饰，不能被`private`、`static`、`synchronized`和`native`等修饰，必须以分号结尾**，**不带花括号。

***

##### <font size="4" color="red">05. Java中调用system.gc会怎样</font>

通知`Gc`开始工作，但`Gc`真正开始工作的时间不确定

***

##### <font size="4" color="red">06. Java中线程wait和sleep区别</font>

1.`sleep()`来自`Thread`类，`wait()`来自`Object`类，调用`sleep`方法的过程中，线程不会释放对象锁，而调用`wait()`方法线程会释放对象锁

2.`sleep()`睡眠后不出让系统资源，`wait`让其他线程可以占用`Cpu`

3.`sleep`需要指定一个睡眠时间，时间一到就会自动唤醒，而`wait()`需要配合`notify()`或者`notifyAll()`使用

***

##### <font size="4" color="red">07. Java中为什么要使用线程池</font>

​		避免频繁地创建和销毁线程，达到线程对象的重用，另外，使用线程池还可以根据项目灵活地控制并发数目。

**(1) newSingleThreadExecutor**
		单个线程的线程池，即线程池中每次只有一个线程工作，单线程串行执行任务
**(2) newFixedThreadExecutor(n)**
		固定数量的线程池，每提交一个任务就是一个线程，直到达到线程池的最大数量，然后后面进入等待队列直到前面的任务完成才继续执行
**(3) newCacheThreadExecutor（推荐使用）**
		可缓存线程池，当线程池大小超过了处理任务所需的线程，那么就会回收部分空闲（一般是60秒无执行）的线程，当有任务来时，又智能的添加新线程来执行。
**(4) newScheduleThreadExecutor**
		大小无限制的线程池，支持定时和周期性的执行线程

***

##### <font size="4" color="red">08. Java中HashMap实现原理</font>

`HashMap`是基于哈希表的`Map`接口的非同步实现，此实现提供所有可选的映射操作，并允许使用`null`值和`null`键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。

***

##### <font size="4" color="red">09. Java中Tcp基础原理</font>

**三次握手：**

![](./img/img(02)/09-01.png)

第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。

第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

**四次挥手：**

![](./img/img(02)/09-02.png)

(1) 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。

(2) 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个`CLOSE-WAIT`状态持续的时间。
(3) 客户端收到服务器的确认请求后，此时，客户端就进入`FIN-WAIT-2`（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
(4) 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，`FIN=1`，`ack=u+1`，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了`LAST-ACK`（最后确认）状态，等待客户端的确认。
(5) 客户端收到服务器的连接释放报文后，必须发出确认，`ACK=1`，`ack=w+1`，而自己的序列号是`seq=u+1`，此时，客户端就进入了`TIME-WAIT`（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的`TCB`后，才进入`CLOSED`状态。
(6) 服务器只要收到了客户端发出的确认，立即进入`CLOSED`状态。同样，撤销`TCB`后，就结束了这次的`TCP`连接。可以看到，服务器结束`TCP`连接的时间要比客户端早一些。

***

##### <font size="4" color="red">10. Docker容器含义</font>

Docker是一个容器化平台，它以容器的形式将您的应用程序及其所有依赖项打包在一起，以确保您的应用程序在任何环境中无缝运行。

***

##### <font size="4" color="red">11. Docker容器有几种状态</font>

四种状态：运行、已暂停、重新启动、已退出。

****

##### <font size="4" color="red">12. Dockerfile中最常见的指令是什么</font>

`FROM`：指定基础镜像
`LABEL`：功能是为镜像指定标签
`RUN`：运行指定的命令
`CMD`：容器启动时要运行的命令

***

##### <font size="4" color="red">13. Docker中常用命令</font>

`docker pull` 拉取或者更新指定镜像
`docker push` 将镜像推送至远程仓库
`docker rm` 删除容器
`docker rmi` 删除镜像
`docker images`列出所有镜像
`docker ps` 列出所有容器

***

##### <font size="4" color="red">14. Tcp与Udp的区别</font>

(1) 基于连接与无连接；
(2) 对系统资源的要求（TCP较多，UDP少）；
(3) UDP程序结构较简单；
(4) 流模式与数据报模式 ；
(5) TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。

***

##### <font size="4" color="red">15. Java中线程含义</font>

​		线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对 运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。Java在语言层面对多线程提供了卓越的支 持，它也是一个很好的卖点。

***

##### <font size="4" color="red">16. Java中线程与进程区别</font>

​		线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。

***

##### <font size="4" color="red">17. Thread 类中的start() 和 run() 方法有什么区别</font>

​		但还是能从此区分出面试者对Java线程模型的理解程度。start()方法被用来启动新创建的线程，而且start()内部 调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启 动，start()方法才会启动新线程。

***

##### <font size="4" color="red">18. 请列举出在JDK中几个常用的设计模式</font>

单例模式：保证被创建一次，节省系统开销。

工厂模式（简单工厂、抽象工厂）：解耦代码。

观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。

外观模式：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。

模版方法模式：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。

状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。

装饰器设计模式：（Decorator design pattern）被用于多个 Java IO 类中。

***

##### <font size="4" color="red">19. 设计模式含义</font>

​		设计模式是世界上各种各样程序员用来解决特定设计问题的尝试和测试的方法。设计模式是代码可用性的延伸

***

##### <font size="4" color="red">20. 单例设计模式</font>

单例模式重点在于在整个系统上共享一些创建时较耗资源的对象。整个应用中只维护一个特定类实例，它被所有组件共同使用。

***

##### <font size="4" color="red">21. 观察者设计模式</font>

​		观察者模式是基于对象的状态变化和观察者的通讯，以便他们作出相应的操作。简单的例子就是一个天气系统，当天气变化时必须在展示给公众的视图中进行反映。这个视图对象是一个主体，而不同的视图是观察者。

***

##### <font size="4" color="red">22. 使用工厂设计模式的好处</font>

​		工厂模式的最大好处是增加了创建对象时的封装层次。如果你使用工厂来创建对象，之后你可以使用更高级和更高性能的实现来替换原始的产品实现或类，这不需要在调用层做任何修改。

***

##### <font size="4" color="red">23. 请举例说明什么情况下会更倾向于使用抽象类而不是接口</font>

​		接口和抽象类都遵循”面向接口而不是实现编码”设计原则，它可以增加代码的灵活性，可以适应不断变化的需求。下面有几个点可以帮助你回答这个问题：

(1) 在 Java 中，你只能继承一个类，但可以实现多个接口。所以一旦你继承了一个类，你就失去了继承其他类的机会了。

(2) 接口通常被用来表示附属描述或行为如：`Runnable、Clonable、Serializable`等等，因此当你使用抽象类来表示行为时，你的类就不能同时是`Runnable`和`Clonable`(注：这里的意思是指如果把`Runnable`等实现为抽象类的情况)，因为在 Java 中你不能继承两个类，但当你使用接口时，你的类就可以同时拥有多个不同的行为。

(3) 在一些对时间要求比较高的应用中，倾向于使用抽象类，它会比接口稍快一点。

(4) 如果希望把一系列行为都规范在类继承层次内，并且可以更好地在同一个地方进行编码，那么抽象类是一个更好的选择。有时，接口和抽象类可以一起使用，接口中定义函数，而在抽象类中定义默认的实现。

***

##### <font size="4" color="red">24. 简单工厂和抽象工厂有什么区别</font>

简单工厂：用来生产同一等级结构中的任意产品，对于增加新的产品，无能为力。

工厂方法：用来生产同一等级结构中的固定产品，支持增加任意产品。

抽象工厂：用来生产不同产品族的全部产品，对于增加新的产品，无能为力；支持增加产品族。

***

##### <font size="4" color="red">25. Redis持久化两种方式</font>

分别是`RDB`与`AOF`

`RDB`：全量一次同步内存中所有序列化的二进制数据，同步慢，数据较小

`AOF`：增量同步操作命令，同步较快，数据量随时间增加而增多，需定期进行`AOF`文件重写，以便减小日志文件

***

##### <font size="4" color="red">26. Java中设计模式原则</font>

**1.单一数据原则**

单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点：

降低类的复杂度：一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多；

提高类的可读性： 复杂性降低，自然其可读性会提；

提高系统的可维护性：可读性提高，那自然更容易维护了；

变更引起的风险降低：变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。

**2.开闭原则**

当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求；

开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下：

对软件测试的影响：软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行；

可以提高代码的可复用性：粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性；

可以提高软件的可维护性：遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。

**3.里氏替换原则**

**原则**：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法；

**引出问题**：用户信息管理，由类 User 完成。现需要将用户信息管理进行扩展，扩展后的功能为 VIP 用户信息管理，其中 VIP 用户管理由原有功能用户信息管理与新功能 VIP 信息管理组成。新功能 VIP用户信息管理 由类 User 的子类 VIP 来完成，则子类 VIPUser 在完成新功能 VIP信息管理 的同时，有可能会导致原有功能用户信息管理发生故障；

**解决方案**：当使用继承时，遵循里氏替换原则。类 VIPUser 继承类 User 时，除添加新的方法完成新增功能 VIP信息管理 外，尽量不要重写父类 User 的方法，也尽量不要重载父类 User 的方法。

里氏替换原则的主要作用如下：

里氏替换原则是实现开闭原则的重要方式之一；

它克服了继承中重写父类造成的可复用性变差的缺点；

它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。

**4.依赖倒置原则**

**原则**：要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合；

**解决方案**：将类 User 修改为依赖接口 ISocialInfo，类 WeChatInfo 和类 SinaInfo 各自实现接口 ISocalInfo，类 User 通过接口 ISocailInfo 间接与类 WeChatInfo 或者类 SinaInfo 发生联系，则会大大降低修改类 User 的几率。

依赖倒置原则的主要作用如下:

降低类间的耦合性；

提高系统的稳定性；

减少并行开发引起的风险；

提高代码的可读性和可维护性。

**5.接口隔离原则**

**原则**：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。；

**引出问题**：类 Student 通过接口 IDepartment 依赖类 Class，类 Teacher 通过接口 IDepartment 依赖类 Group，如果接口 IDepartment 对于类 Student 和类 Teacher 来说不是最小接口，则类 Class 和类 Group 必须去实现他们不需要的方法；

**解决方案**：将臃肿的接口 IDepartment 拆分为独立的几个接口，类 Student 和类 Teacher 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。

接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点:

将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性；

接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性；

如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使* 设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险；

使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义；

能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。

**6.迪米特原则**

**原则**：一个对象应该对其他对象保持最少的了解；

**引出问题**：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大；

**解决方案**：尽量降低类与类之间的耦合。

迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点：

降低了类之间的耦合度，提高了模块的相对独立性；

由于亲合度降低，从而提高了类的可复用率和系统的扩展性。

***

##### <font size="4" color="red">27. Java中线程生命周期</font>

​		一个线程不是被创建了马上就开始执行，也不是一直处于执行状态。在线程的整个生命周期中会经历**新建**（New）、
**就绪**（Runnable）、**运行**（Running）、**阻塞**（Blocked）和**销毁**（Terminated）5 种状态。

***

##### <font size="4" color="red">28. Java中Mqtt原理</font>

MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（`publish/subscribe`）模式的“轻量级”通讯协议，该协议构建于TCP/IP协议上，

MQTT协议运行在TCP/IP或其他网络协议，提供有序、无损、双向连接。其特点包括：

1. 使用的发布/订阅消息模式，它提供了一对多消息分发，以实现与应用程序的解耦。

2. 对负载内容屏蔽的消息传输机制。

3. 对传输消息有三种服务质量（QoS）：

4. - `最多一次`，这一级别会发生消息丢失或重复，消息发布依赖于底层TCP/IP网络。即：<=1
   - `至多一次`，这一级别会确保消息到达，但消息可能会重复。即：>=1
   - `只有一次`，确保消息只有一次到达。即：＝1。在一些要求比较严格的计费系统中，可以使用此级别

5. 数据传输和协议交换的最小化（协议头部只有2字节），以减少网络流量

6. 通知机制，异常中断时通知传输双方

***

##### <font size="4" color="red">29. Java中Zookeeper介绍</font>

Zookeeper 是一个分布式协调服务。Zookeeper 提供了一个类似于 Linux 文件系统的树形结构（可认为是轻量级的内存文件系统，但只适合存少量信息，完全不适合存储大量文件或者大文件），同时提供了对于每个节点的监控与通知机制。可用于服务发现，分布式锁，分布式领导选举，配置管理等。

***

##### <font size="4" color="red">30. Java中冒泡排序</font>

```java
public class demo_sort {
    public static void main(String[] args) {
        //冒泡排序算法
        int[] numbers=new int[]{1,5,8,2,3,9,4};
        //需进行length-1次冒泡
        for(int i=0;i<numbers.length-1;i++)
        {
            for(int j=0;j<numbers.length-1-i;j++)
            {
                if(numbers[j]>numbers[j+1])
                {
                    int temp=numbers[j];
                    numbers[j]=numbers[j+1];
                    numbers[j+1]=temp;
                }
            }
        }
        System.out.println("从小到大排序后的结果是:");
        for(i=0;i<numbers.length;i++)
            System.out.print(numbers[i]+" ");
    }
```

***

##### <font size="4" color="red">31. Java中有没有goto语句</font>

​		goto 是Java中的保留字，在目前版本的Java中没有使用。（根据James Gosling（Java之父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字）

****

##### <font size="4" color="red">32. Java中抽象类和接口区别</font>

​		抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。`接口比抽象类更加抽象`，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。

***

##### <font size="4" color="red">33. Java中打印当前时刻</font>

```java
import java.util.Calendar;

class YesterdayCurrent {
    public static void main(String[] args){
        Calendar cal = Calendar.getInstance();
        cal.add(Calendar.DATE, -1);
        System.out.println(cal.getTime());
    }
}
```

***


##### <font size="4" color="red">41. Java中throw和throws的区别</font>

​		throws是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。而throw则是指抛出的一个具体的异常类型。

***

##### <font size="4" color="red">42. Java中final、finally、finalize 有什么区别</font>

final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。

finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。

finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize(),回收垃圾。

***

##### <font size="4" color="red">43. Java中try-catch-finally中哪个部分可以省略</font>

catch 可以省略

​		更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。

***

##### <font size="4" color="red">44. Java中Jsonp实现原理</font>

​		`jsonp`即`json+padding`，动态创建`script`标签，利用`script`标签的`src`属性可以获取任何域下的`js`脚本，通过这个特性(也可以说漏洞)，服务器端不在返货`json`格式，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。

***

##### <font size="4" color="red">45. Java中kafka可以脱离zookeeper单独使用吗</font>

`kafka`不能脱离`zookeeper`单独使用，因为`kafka`使用`zookeeper`管理和协调`kafka`的节点服务器。

***

##### <font size="4" color="red">46. Java中kafka几种策略</font>

kafka有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。

***

##### <font size="4" color="red">47. 什么情况会导致kafka运行变慢</font>

`cpu`性能瓶颈
磁盘读写瓶颈
网络瓶颈

***

##### <font size="4" color="red">48. 使用kafka集群需要注意什么</font>

集群的数量不是越多越好，最好不要超过 7 个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低。
集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。

***

##### <font size="4" color="red">49. Java中线程池</font>

**1.作用**：线程复用、控制最大并发数、管理线程。线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。

**2.线程复用：**每一个Thread的类都有一个 start() 方法。 当调用 start 启动线程时 Java 虚拟机会调用该类的 run() 方法。 那么该类的 run() 方法中就是调用了 Runnable 对象的 run() 方法。 我们可以继承重写Thread 类，在其 start () 方法中添加不断循环调用传递过来的 Runnable 对象。 这就是线程池的实现原理。循环方法中不断获取 Runnable 是用 Queue 实现的，在获取下一个 Runnable 之前可以是阻塞的。

**3.线程池组成：**

(1) 线程池管理器：用于创建并管理线程池；

(2) 工作线程：线程池中的线程；

(3) 任务接口：每个任务必须实现的接口，用于工作线程调度其运行；

(4) 任务队列：用于存放待处理的任务，提供一种缓冲机制。

Java中的线程池是通过 Executor 框架实现的，该框架中用到了 Executor，Executors，ExecutorService，ThreadPoolExecutor ，Callable 和 Future、FutureTask 这几个类。ThreadPoolExecutor 的构造方法如下：

```java
/**
* @param corePoolSize 指定线程池中的线程数量
* @param maximumPoolSize 指定线程池中的最大线程数量
* @param keepAliveTime 当前线程池数量超过 corePoolSize 时，多余的空闲线程的存活时间
* @param unit keepAliveTime 的单位
* @param workQueue 任务队列，被提交但尚未被执行的任务
*/
public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) {
    // threadFactory 线程工厂，用于创建线程，一般用默认的即可
    // handler 拒绝策略，当任务太多来不及处理，如何拒绝任务
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);
}
```

**4.拒绝策略**

​		线程池中的线程已经用完了，无法继续为新任务服务，同时，等待队列也已经排满了，再也塞不下新任务了。这时候我们就需要拒绝策略机制合理的处理这个问题。

**JDK内置的拒绝策略：**

(1) `AbortPolicy`：直接抛出异常，阻止系统正常运行

(2) `CallerRunsPolicy`：只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。

(3) `DiscardOldestPolicy`：丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务

(4) `DiscardPolicy`：该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢失，这是最好的一种方案。

***

##### <font size="4" color="red">50. Java中Redis哨兵模式</font>

​		由于Redis的主从同步是异步进行的，所以Redis主从集群不满足事务的一致性，同时Redis在主从网络不可用的情况下，主节点依旧可以提供服务，所以Redis主从集群满足事物的可用性。Redis只能保证数据的最终一致性。

**增量同步：**Redis主节点将所有key的修改指令写入到一段定长的内存缓冲区中，然后将修改指令同步到从节点，同时从节点将指令执行情况（偏移量）反馈到主机节点，以此来进行主从同步。

> **注：**由于主节点的指令缓冲区是定长的，所以当缓冲区写满后，又会缓冲区起始位置开始覆盖写入新的指令。

**快照同步：**当某种原因（如主从网络延迟、从节点执行指令效率过低等）导致增量同步的数据不一致的时候，就需要快照同步来修复数据。快照同步首先需要将主节点上的数据进行一次bgsave，将内存数据全部持久化到磁盘，然后同过网络传输到从节点，写入从节点磁盘。从节点再使用快照加载数据，当数据加载完成后，从节点反馈给主节点，继续进行增量同步。

**无盘复制：**本质上相当于快照同步，只不过少了主节点数据写入磁盘的步骤，换成主节点内存数据直接写入从节点的磁盘，然后继续快照同步的后续操作 。

***

##### <font size="4" color="red">51. Java中Jvm内存模型</font>

![](./img/img(02)/51-01.png)

JVM内存主要分为三部分：线程私有（Thread Local）、线程共享（Thread Shared）、直接内存（Direct Memory）。

**线程私有区域：**从字面意思可以看出，这部分内存，是归属于每个线程独立拥有的部分。其生命周期与线程生命周期一致。线程私有区域可以分为两部分程序计数器*、*虚拟机栈和本地方法栈。

1.程序计数器：用来记录线程下一条字节码指令地址，方便线程切换后，下次切回时能够继续执行

(1) 如果当前线程正在执行java方法的话，计数器记录的是虚拟机下一条字节码指令的地址，如果执行的是`Native`方法的话，则为空。

(2) 每个线程都有一个独立的程序计数器

(3) 程序计数器是唯一一个在虚拟机中没有规定任何`OutOfMemoryError`情况的区域

2.虚拟机栈

(1) 虚拟机栈是描述 Java 方法执行的内存模型

(2) 每个方法在执行的同时都会创建一个栈帧（`Stack Frame`）用于存储局部变量表、操作数栈、动态链接、方法出口等信息

(3) 栈帧随着方法调用而创建，随着方法结束而销毁（无论方法是正常完成还是异常完成都算作方法结束）

(4) 每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程

(5) 平时说的栈一般指局部变量表部分

![](./img/img(02)/51-02.png)

**线程共享区域：**线程共享区域随虚拟机的启动而创建，随虚拟机的关闭而销毁。

**堆：**堆是被线程共享的一块内存区域，所有对象实例及数组都要在堆上分配内存

(1) 堆也是垃圾收集器进行垃圾收集的最重要的内存区域

(2) 因为堆存放的对象是线程共享的，所以多线程的时候也需要同步机制

**方法区：**方法区即我们常说的永久代(`Permanent Generation`)，用于存储已被虚拟机加载的类信息、常量、静态变量，如 static 修饰的变量加载类的时候就被加载到方法区中

**直接内存：**直接内存并不是`JVM`运行时数据区的一部分，但也会被频繁的使用（在`NIO`中，可以使用`Native`函数库直接分配堆外内存，然后使用`DirectByteBuffer`对象作为这块内存的引用进行操作，避免了在`Java`堆和`Native`堆中来回复制数据， 因此在一些场景中可以显著提高性能）。

***

##### <font size="4" color="red">52. Java中数组和链表的区别</font>

**数组：**有下标和数据区域两部分组成

**链表：**有数据区域和指向下一个指针地址两部分组成

**数组特点：**

(1) 在内存中，数组是一块连续的区域

(2) 数组需要预留空间，在使用前要申请占内存的大小

(3) 插入数据和删除数据效率低，插入数据时，，这个位置后面的数据在内存中都要向后移。删除数据时，这个数据后面的数据都要往前移动。

(4) 随机读取效率很高。因为数组是连续的，知道每一个数据的内存地址，可以直接找到给地址的数据。

(5) 并且不利于扩展，数组定义的空间不够时要重新定义数组

**链表特点：**

(1) 在内存中可以存在任何地方，不求连续

(2) 每个数据都保存了下一个数据的内存地址，通过这个地址找到下一个数据

(3) 增加数据和删除数据很容易

(4) 查找数据时效率低，因为不具有随机访问性，所以访问某个位置的数据都要从第一数据开始访问，然后从第一个数据的地址找到第二个数据，依此类推。

(5) 不指定大小，扩展方便。

***

##### <font size="4" color="red">53. Java中Vector、ArrayList和LinkedList区别</font>

`Vector`、`ArrayList`都是以数组的形式存储在内存中，所以查询效率高，新增和删除效率不高，但是`Vector`被`Synchronized`修饰，所以是线程安全的，`ArrayList`线程不安全。

`LinkedList`则以链表的形式进行存储，所以查询效率低，新增和删除效率高，并且线程不安全。

***

##### <font size="4" color="red">54. Java中接口限流、熔断、降级</font>

​		缓存、降级和限流。缓存的目的是提升系统访问速度和增大系统能处理的容量，可谓是抗高并发流量的银弹；而降级是当服务出问题或者影响到核心流程的性能则需要暂时屏蔽掉，待高峰或者问题解决后再打开；而有些场景并不能用缓存和降级来解决，比如稀缺资源（秒杀、抢购）、写服务（如评论、下单）、频繁的复杂查询（评论的最后几页），因此需有一种手段来限制这些场景的并发/请求量，即限流。

​		限流的目的是通过对并发访问/请求进行限速或者一个时间窗口内的的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务（定向到错误页或告知资源没有了）、排队或等待（比如秒杀、评论、下单）、降级（返回兜底数据或默认数据，如商品详情页库存默认有货）。

**限流算法：**

1.漏桶算法

​		漏桶(Leaky Bucket)算法思路很简单,水(请求)先进入到漏桶里,漏桶以一定的速度出水(接口有响应速率),当水流入速度过大会直接溢出(访问频率超过接口响应速率),然后就拒绝请求,可以看出漏桶算法能强行限制数据的传输速率。

2.令牌算法

​		令牌桶算法(Token Bucket)和 Leaky Bucket 效果一样但方向相反的算法,更加容易理解.随着时间流逝,系统会按恒定1/QPS时间间隔(如果QPS=100,则间隔是10ms)往桶里加入Token(想象和漏洞漏水相反,有个水龙头在不断的加水),如果桶已经满了就不再加了.新请求来临时,会各自拿走一个Token,如果没有Token可拿了就阻塞或者拒绝服务。令牌桶的另外一个好处是可以方便的改变速度. 一旦需要提高速率,则按需提高放入桶中的令牌的速率. 一般会定时(比如100毫秒)往桶中增加一定数量的令牌, 有些变种算法则实时的计算应该增加的令牌的数量。

3.计数器算法

​		计数器算法是限流算法里最简单也是最容易实现的一种算法。比如我们规定，对于A接口来说，我们1分钟的访问次数不能超过100个。那么我们可以这么做：在一开 始的时候，我们可以设置一个计数器counter，每当一个请求过来的时候，counter就加1，如果counter的值大于100并且该请求与第一个 请求的间隔时间还在1分钟之内，那么说明请求数过多；如果该请求与第一个请求的间隔时间大于1分钟，且counter的值还在限流范围内，那么就重置`counter`

***

##### <font size="4" color="red">55. HashMap原理</font>

1.`hash`为什么要用红黑树而不用`B+`树

​		`B+`树在数据库中被应用的原因就是`B+`树比`B`树更加“矮胖”，`B+`树的非叶子结点不存储数据，所以每个结点能存储的关键字更多。所以`B+`树更能应对大量数据的情况。

​		`Jdk1.7`的`HashMap`本来是数组+链表的形式，链表由于其查找慢的特点，所以需要被查找效率更高的树结构来替换。如果用`B+`树的话，在数据量不是很多的情况下，数据都会“挤在”一个结点里面。这个时候遍历效率就退化成了链表。

***

##### <font size="4" color="red">56. 分布式架构含义</font>

​		分布式架构就是将传统结构按照模块进行拆分，不同的人负责不同的模块，不会产生代码冲突问题，方便开发。

***