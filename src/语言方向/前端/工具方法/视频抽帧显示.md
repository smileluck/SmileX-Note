[TOC]

---

# 基于CANVAS视频抽帧显示 (TS)

```typescript
export interface videoInfo {
  blob: Blob | null;
  url: string;
}

// 画视频
const drawVideo = (video: HTMLVideoElement) => {
  return new Promise<videoInfo>(success => {
    const cvs = document.createElement('canvas');
    const ctx = cvs.getContext('2d');
    cvs.width = video.videoWidth;
    cvs.height = video.videoHeight;
    ctx?.drawImage(video, 0, 0, cvs.width, cvs.height);
    cvs.toBlob(blob => {
      success({
        blob,
        url: URL.createObjectURL(blob as Blob)
      });
    });
  });
};

// 视频截取工具
export function captureFrame(videoFile: File, time: number = 0) {
  return new Promise<videoInfo>(succeed => {
    const video = document.createElement('video');
    video.currentTime = time;
    video.muted = true;
    video.preload = 'auto';
    video.autoplay = true;
    video.setAttribute('crossOrigin', 'Anonymous'); // 处理跨域
    video.setAttribute('preload', 'auto'); // auto|metadata|none
    video.src = URL.createObjectURL(videoFile);
    video.oncanplay = async () => {
      // 延时500ms防止白屏问题
      setTimeout(async () => {
        const res = await drawVideo(video);
        succeed(res);
      }, 500);
    };
  });
}
// blob\file转base64
export function toBase64(blob: Blob | File) {
  return new Promise<string>(success => {
    var reader = new FileReader();
    reader.readAsDataURL(blob);
    reader.onload = (e: any) => {
      success(e.target.result);
    }
  })
}
```


# 基于JS 版本
```javascript

// 画视频
const drawVideo = (video) => {
  return new Promise(success => {
    const cvs = document.createElement('canvas');
    const ctx = cvs.getContext('2d');
    cvs.width = video.videoWidth;
    cvs.height = video.videoHeight;
    ctx?.drawImage(video, 0, 0, cvs.width, cvs.height);
    cvs.toBlob(blob => {
      success({
        blob,
        url: URL.createObjectURL(blob),
        width: video.videoWidth,
        height: video.videoHeight
      });
    });
  });
};

// 画视频
export const drawVideoCanvas = (video) => {
  return new Promise(success => {
    const cvs = document.createElement('canvas');
    const ctx = cvs.getContext('2d');
    cvs.width = video.videoWidth;
    cvs.height = video.videoHeight;
    ctx?.drawImage(video, 0, 0, cvs.width, cvs.height);
    success(cvs)
  });
};

// 视频截取工具
export function captureFrame(videoFile, time = 0, callback) {
  return new Promise(succeed => {
    const video = document.createElement('video');
    video.currentTime = time;
    video.muted = true;
    video.preload = 'auto';
    video.autoplay = true;
    video.setAttribute('crossOrigin', 'Anonymous'); // 处理跨域
    video.setAttribute('preload', 'auto'); // auto|metadata|none
    if (typeof videoFile === 'string') {
      video.src = videoFile
    } else {
      video.src = URL.createObjectURL(videoFile);
    }
    video.oncanplay = async () => {
      // 延时500ms防止白屏问题
      setTimeout(async () => {
        video.currentTime = time;
        video.pause()
        const res = await drawVideo(video);
        succeed(res);
        // if (callback){
        //   console.log('callback exists');
        //   callback(video.videoWidth, video.videoHeight);
        // }
      }, 500);
    };
  });
}
// blob\file转base64
export function toBase64(blob) {
  return new Promise(success => {
    const reader = new FileReader();
    reader.readAsDataURL(blob);
    reader.onload = (e) => {
      success(e.target.result);
    };
  });
}

//2024年7月25日
// URL 转换为 Base64 数据 URL
export async function urlToBase64(url) {
  const blob = await urlToBlob(url);
  return toBase64(blob);
}

//2024年7月25日
// URL 转换为 Base64 数据 URL
export async function urlToBlob(url) {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error('Failed to fetch the image.');
  }
  const blob = await response.blob();
  return blob;
}


// 从 URL 获取 File 对象
export async function fetchFileFromUrl(url, filename = '') {
  try {
    // 使用 fetch 从 URL 获取数据
    const response = await fetch(url);

    // 检查请求是否成功
    if (!response.ok) {
      throw new Error('Network response was not ok.');
    }

    // 将响应数据转换为 Blob 对象
    const blob = await response.blob();

    if (filename == '') {
      const urls = url.split("?")[0].split('/')
      filename = urls[urls.length - 1];
    }

    // 将 Blob 转换为 File 对象（如果需要）
    const file = new File([blob], filename, { type: blob.type });

    return file; // 返回 File 对象
  } catch (error) {
    console.error('Error fetching file:', error);
    throw error;
  }
}

// base64 to Blob
export function toBlob(dataurl) {
  var arr = dataurl.split(','),
    mime = arr[0].match(/:(.*?);/)[1],
    bstr = atob(arr[1]),
    n = bstr.length,
    u8arr = new Uint8Array(n);
  while (n--) {
    u8arr[n] = bstr.charCodeAt(n);
  }
  return new Blob([u8arr], { type: mime });
}

// 通过base64获取图片宽高
export function getImageSizeByBase64(base64, callback) {
  var img = new Image();
  img.onload = function () {
    if (callback) {
      callback({ width: img.width, height: img.height });
    }
  };
  img.src = base64;
}

//通过url获取blob
export async function fetchBlob(blobUrl) {
  try {
    const response = await fetch(blobUrl);
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    const blob = await response.blob();
    return blob;
  } catch (error) {
    console.error('Fetching the Blob failed:', error);
    return null;
  }
}

// 创建一个可存取该file的url的函数
export function getObjectURL(file) {
  // console.log(file)
  var url = null;
  // 下面函数执行的效果是一样的，只是需要针对不同的浏览器执行不同的 js 函数而已
  if (window.createObjectURL != undefined) { // basic
    url = window.createObjectURL(file);
  } else if (window.URL != undefined) { // mozilla(firefox)
    url = window.URL.createObjectURL(file);
  } else if (window.webkitURL != undefined) { // webkit or chrome
    url = window.webkitURL.createObjectURL(file);
  }
  return url;
}

// aysnc read file by promise
export function readFile(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = async () => {
      resolve(reader.result);
    };
    reader.readAsDataURL(file);
  })
}
```
