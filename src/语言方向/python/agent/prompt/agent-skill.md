- [Skill](#skill)
  - [基础](#基础)
    - [一、核心背景：为何需要 Skills？](#一核心背景为何需要-skills)
    - [二、Skills 核心认知](#二skills-核心认知)
      - [1. 定义与本质](#1-定义与本质)
      - [2. 工作原理](#2-工作原理)
      - [3. 执行流程](#3-执行流程)
    - [三、Skills 与易混淆概念的区别](#三skills-与易混淆概念的区别)
      - [（一）核心概念对比（Skills/Command/MCP）](#一核心概念对比skillscommandmcp)
      - [（二）补充概念对比（Rules/Agent/Memory）](#二补充概念对比rulesagentmemory)
      - [（三）协同关系说明](#三协同关系说明)
      - [(四) 协同工作流示例](#四-协同工作流示例)
    - [四、好 Skills 的设计标准与编写方法](#四好-skills-的设计标准与编写方法)
      - [1. 评判维度（Good vs Bad）](#1-评判维度good-vs-bad)
      - [2. 编写技巧](#2-编写技巧)
      - [3. 认识误区](#3-认识误区)
    - [五、社区热门 Skills 推荐](#五社区热门-skills-推荐)
      - [1. 官方核心 Skills（Claude 仓库）](#1-官方核心-skillsclaude-仓库)
      - [2. 社区资源](#2-社区资源)
    - [六、TRAE 中 Skills 的实操（创建+使用）](#六trae-中-skills-的实操创建使用)
      - [1. 创建方式](#1-创建方式)
      - [2. 使用方法](#2-使用方法)
      - [3. 实践场景：Spec Coding 工作流](#3-实践场景spec-coding-工作流)
    - [七、常见问题与核心价值](#七常见问题与核心价值)
      - [1. 常见 Q\&A](#1-常见-qa)
      - [2. 核心价值](#2-核心价值)
    - [结语](#结语)
- [Skill设计与开发最佳实践：从“能用”到“会用”](#skill设计与开发最佳实践从能用到会用)
  - [核心目标](#核心目标)
  - [一、Skill的定义与常见认知误区](#一skill的定义与常见认知误区)
    - [1. 核心定义](#1-核心定义)
    - [2. 三大常见误区（正反示例对比）](#2-三大常见误区正反示例对比)
  - [二、Skill的设计标准与核心原则](#二skill的设计标准与核心原则)
    - [1. 元数据规范（name/description）](#1-元数据规范namedescription)
    - [2. 指导方式的自由度分级](#2-指导方式的自由度分级)
    - [3. 五大核心设计标准（正反示例对比）](#3-五大核心设计标准正反示例对比)
  - [三、Skill构建与迭代的最佳流程（评测驱动+失败优先）](#三skill构建与迭代的最佳流程评测驱动失败优先)
    - [1. 建立无Skill基线，识别真实问题](#1-建立无skill基线识别真实问题)
    - [2. 定义评测用例（优先于开发Skill）](#2-定义评测用例优先于开发skill)
    - [3. 编写最小化Skill，明确最短成功路径](#3-编写最小化skill明确最短成功路径)
    - [4. 补充边界条件与结构化示例](#4-补充边界条件与结构化示例)
    - [5. 评测回归与持续迭代](#5-评测回归与持续迭代)
    - [6. 结合真实使用路径校准](#6-结合真实使用路径校准)
  - [四、让Skill可维护、可扩展的关键技巧](#四让skill可维护可扩展的关键技巧)
    - [1. 渐进式披露（减轻模型加载负担）](#1-渐进式披露减轻模型加载负担)
    - [2. 工作流与反馈闭环（降低遗漏/跑偏风险）](#2-工作流与反馈闭环降低遗漏跑偏风险)
      - [（1）分析类任务示例（技术方案评估）](#1分析类任务示例技术方案评估)
      - [（2）代码类任务示例（依赖版本升级）](#2代码类任务示例依赖版本升级)
    - [3. 可执行脚本的加固原则（失败可预期、输出可理解）](#3-可执行脚本的加固原则失败可预期输出可理解)
  - [五、借助AI高效创建与迭代Skill](#五借助ai高效创建与迭代skill)
    - [1. 初次创建（从具体任务抽象）](#1-初次创建从具体任务抽象)
    - [2. 持续迭代（从使用反馈优化）](#2-持续迭代从使用反馈优化)
  - [六、反模式检查清单（规避典型问题）](#六反模式检查清单规避典型问题)
  - [核心总结](#核心总结)


# Skill
该链接内容是一份关于 AI Agent 中“Skills（技能）”的完整指南，从概念、原理、设计标准到实操应用全面展开，核心是帮助用户理解并运用 Skills 解决 Agent 执行混乱、工具调用低效等问题，以下是结构化总结：

## 基础

### 一、核心背景：为何需要 Skills？
AI Agent 常存在“规则失效（不遵循预设规则）、执行失控（无条理）、工具迷失（不会用集成工具）”等问题，而 Skills 作为“高级技能包”，能让 Agent 从“聊天机器人”进化为“得力干将”，实现可靠、可控、可复用的任务执行。

### 二、Skills 核心认知
#### 1. 定义与本质
- 由 Anthropic 提出，是大模型 Claude 的能力扩展机制，现已成为 Agent 开发的标准扩展规范。
- 本质：封装特定任务所需的**领域知识、操作流程、工具调用逻辑和最佳实践**的“技能包”，让 Agent 从“通才”变为特定领域“专家”。
- 物理形式：以文件夹存在，包含三类核心文件：
  - SKILL.md：使用场景、步骤、注意事项等自然语言说明；
  - Script 脚本：Agent 可执行的代码；
  - Reference 引用：参考文档、模板等关联资源。

#### 2. 工作原理
- 官方解释：https://platform.claude.com/docs/en/agents-and-tools/agent-skills/overview
- 运行环境：沙盒环境，支持大模型访问文件系统、执行 bash 命令。
- 渐进式加载机制（平衡效率与效果）：
  | 级别 | 加载时机 | Token 消耗 | 核心内容 |
  |------|----------|------------|----------|
  | L1（元数据） | 启动时始终加载 | 约 100/技能 | 名称、描述（YAML 格式，类似“名片”） |
  | L2（说明文档） | 技能触发时 | ＜5000 | SKILL.md 中的工作流程、操作指南 |
  | L3（资源与代码） | 按需加载 | 几乎无限制 | 脚本（.py/.js）、配置文件等（不进入上下文） |
- 调用逻辑：用户需求→匹配元数据（找对应技能）→读取 SKILL.md（懂操作）→按需执行脚本/工具→反馈结果。

#### 3. 执行流程
```
├─ 用户发起需求：“帮我...（用户需求）”
└─ Agent执行流程
   ├─ 1. 匹配Skill
   │  └─ 扫描所有Skill元数据
   │     └─ Skill Metadata返回最匹配的Skill
   ├─ 2. 获取执行指南
   │  └─ 读取SKILL.md
   │     └─ SKILL.md返回工作流程和指南
   └─ 3. 执行任务（按需）
      └─ 调用Skill Scripts
         └─ Skill Scripts返回执行结果
            └─ Agent向用户反馈：“任务完成（或提问）”
```


### 三、Skills 与易混淆概念的区别
以“厨房做饭”为核心类比，结合官方定义与实操场景，明确各概念的定位与差异：


#### （一）核心概念对比（Skills/Command/MCP）
| 概念          | 厨房类比         | 官方定义核心特征                                                                 | 适用场景典型案例                                                                 |
|---------------|------------------|----------------------------------------------------------------------------------|----------------------------------------------------------------------------------|
| **Skills（技能）** | 完整菜谱（含步骤+工具+经验） | 模型自动匹配，封装**流程+工具+规范**的模块化能力包；支持渐进式加载（元数据→详细说明→脚本） | 复杂任务的标准化执行：<br>1. 按品牌规范生成PPT<br>2. 自动提取PDF表格并生成Excel<br>3. 按SOP完成代码审查 |
| **Command（快捷指令）** | 微波炉“加热3分钟”按钮 | 用户主动触发的**单一固定操作**；绕过模型思考，强制执行预设动作                     | 高频重复的简单任务：<br>1. 用`/clear`清空对话上下文<br>2. 用`/parse_excel`一键解析表格 |
| **MCP（原子工具）** | 单一厨具（如锅/铲） | 连接外部系统的**通用协议**；仅提供基础工具能力，需手动组合使用                     | 外部系统/数据的对接：<br>1. 调用数据库获取实时订单数据<br>2. 同步报告到Jira/飞书 |


#### （二）补充概念对比（Rules/Agent/Memory）
| 概念          | 厨房类比         | 核心特点                                                                         | 与Skills的关系                                                                   |
|---------------|------------------|----------------------------------------------------------------------------------|----------------------------------------------------------------------------------|
| **Rules（规则）** | 厨房安全禁忌（如“开火必关窗”） | 与项目强绑定的**硬约束**；定义Agent的行为边界（能做/不能做）                      | 可嵌入Skills中，作为任务执行的“红线”（如“生成报告时不得泄露用户隐私”）|
| **Agent（智能体）** | 专职厨师（负责统筹做饭） | 封装模型能力+角色+执行逻辑的**自治系统**；可调度Skills/Command/MCP协作           | 是Skills的“使用者”，通过匹配Skills完成复杂任务（如“让厨师用‘红烧肉Skill’做菜”） |
| **Memory（记忆）** | 厨师记下来的“上次盐放多了”经验 | 对话提炼的**上下文信息**；分短期（会话内）/长期（向量库存储）                     | 可迁移至Skills中，优化执行效果（如“根据用户过往偏好调整报告排版”）|


#### （三）协同关系说明
实际场景中，这些概念常组合使用：
- **Skills + MCP**：用Skills封装“生成财务报告”的流程，通过MCP调用企业数据库获取实时数据；
- **Command + Skills**：用`/report`快捷指令（Command）直接触发“生成月报”的Skill；
- **Agent + Skills + Memory**：Agent调度“数据分析Skill”，结合Memory中的历史偏好输出定制化结果。

#### (四) 协同工作流示例
我整理了一个“生成月度销售报告”的协同工作流示例，清晰展示各概念的配合逻辑：

```markdown
# 「生成月度销售报告」协同工作流
├─ 触发阶段：用户操作
│  └─ 点击快捷指令（Command）：/generate_sales_report
├─ 执行主体：销售Agent（专职智能体）
│  ├─ 第一步：调用Memory（记忆）
│  │  └─ 读取历史偏好：“用户需要包含区域对比图+竞品数据”
│  ├─ 第二步：匹配并触发Skill（技能）：“月度销售报告生成”
│  │  ├─ Skill内的Rules（规则）约束：“不得泄露未公开的客户信息”
│  │  ├─ Skill调用MCP（原子工具）1：“企业销售数据库接口”
│  │  │  └─ 获取本月各区域销售数据
│  │  └─ Skill调用MCP（原子工具）2：“竞品数据API”
│  │     └─ 获取同期竞品市场份额
│  └─ 第三步：Skill执行流程
│     ├─ 自动整理数据+生成区域对比图
│     ├─ 按Memory中的偏好调整排版
│     └─ 输出符合Rules的报告初稿
└─ 交付阶段
   └─ Agent将报告反馈给用户
```

这个流程里，Command负责快速触发、Agent统筹全局、Memory提供个性化依据、Skill封装核心流程、MCP对接外部数据、Rules保障合规性，完整覆盖了各概念的协同逻辑。


### 四、好 Skills 的设计标准与编写方法
> 最佳实践：https://platform.claude.com/docs/zh-CN/agents-and-tools/agent-skills/best-practices

#### 1. 评判维度（Good vs Bad）
- 单一职责：专注一件事；
- 描述清晰：自然语言明确输入、输出、功能，避免模糊表述；
- 参数精简：命名语义化（如 city_name），附说明和示例；
- 可组合性：输出可作为其他技能输入，支持构建复杂任务流。

#### 2. 编写技巧
- 原子性：小而美，专注具体问题；
- 给例子（Few-Shot）：用输入输出示例替代复杂解释；
- 立规矩：定角色、拆步骤、明确禁忌；
- 造接口：明确定义输入参数和输出格式（如 JSON/Markdown）；
- 勤复盘：迭代优化 Bad Case，补充规则/反例。

#### 3. 认识误区
- Skill 等同于prompt。Skills是一个可长期复用、输入输出明确的能力模块，强调的是稳定、确定且易于工程化维护。而 Prompt 更偏向临时性、探索性和即兴交互，两者在设计目标和工程要求上完全不同。
- Skill是给人看的文档。SKILL.md 文件的内容应使用模型可解析的结构化语言，明确约束其行为边界，并精确描述何时使用（When）、如何执行（How）、输出结果（What）。
- Skill越复杂越好。职责单一、边界清晰的 Skill，更容易在正确的时机被选中并稳定执行。过于复杂的 Skill 反而会降低命中率。

### 五、社区热门 Skills 推荐
#### 1. 官方核心 Skills（Claude 仓库）
> https://github.com/anthropics/skills


| 类别 | 代表技能 | 功能 | 适用场景 |
|------|----------|------|----------|
| 文档处理 | document-Skills/docx/pdf/pptx/xlsx | 文档创建、编辑、提取、格式处理 | 办公文档自动化 |
| 设计类 | frontend-design/canvas-design | 生成独特前端界面、视觉艺术作品 | Web 组件/海报设计（避 AI 审美） |
| 开发辅助 | mcp-builder/skills-creator | 构建 MCP 服务器、开发新 Skills | 扩展 Agent 工具能力 |
| 其他 | brand-guidelines/internal-comms | 品牌规范应用、内部沟通文档撰写 | 视觉格式化、职场写作 |

#### 2. 社区资源
- Awesome 集合：ComposioHQ/awesome-claude-Skills 等；
- 分发市场：Skillsmp（中文）；
- 工具类：Skills_Seekers（文档/网页转 Skills）、claude-scientific-writer（学术创作）。

### 六、TRAE 中 Skills 的实操（创建+使用）
#### 1. 创建方式
- 方式 1：设置面板→规则技能→创建（填写名称、描述、主体）；
- 方式 2：项目目录下新建.trae/Skills/xxx，放入 SKILL.md 等文件，自动识别；
- 方式 3：对话中调用内置 skills-creator，自然语言描述需求生成技能。

#### 2. 使用方法
- 自然语言输入需求（如“提取 PDF 表格”“设计科技感登录页”），系统自动匹配并调用对应技能；
- 技能自动加载文档、执行脚本，分步引导完成任务。

#### 3. 实践场景：Spec Coding 工作流
- 核心逻辑：先定义需求规范，再编码，通过多 Skills 分工协作；
- 所需技能：
  - 角色型：requirement-analyst（需求分析→REQUIREMENT.md）、system-architect（技术设计→DESIGN.md）、task-planner（任务拆解→TODO.md）、spec-coder（编码执行）；
  - 工具型：feishu-doc-writing（飞书文档语法/协作）；
  - 统筹型：spec-coding（编排全流程，调度上述技能）。

### 七、常见问题与核心价值
#### 1. 常见 Q&A
- 不生效原因：Description 模糊，Agent 无法匹配；
- LLM 影响：强模型擅长“选技能、定策略”，Skills 决定“执行稳定性、最低水平”；
- 局限性：不擅长高度创造力任务（写诗/品牌设计）、实时决策类任务、单纯知识问答；
- 二次开发：支持 Fork 社区 Skills，适配自身需求。

#### 2. 核心价值
- 解决痛点：动态加载机制避免 Token 浪费，提升执行精准性；
- 降低门槛：丰富的官方/社区资源，支持快速复用；
- 生态意义：推动 Agent 从“对话助手”变为“可信赖执行者”，实现跨领域协作。

### 结语
Skills 是 Agent 进化的关键，通过封装领域经验实现能力复用。建议从创建首个技能入手，将专业经验转化为可复用工具，让 AI 成为延伸自身价值的“行动派”伙伴。



# Skill设计与开发最佳实践：从“能用”到“会用”
> 参考资料
> https://platform.claude.com/docs/zh-CN/agents-and-tools/agent-skills/best-practices
> https://mp.weixin.qq.com/s/Aa90V25Vtt1WtQ-6RrzcUQ
## 核心目标
系统掌握Skill的定义规范、设计原则、构建流程与优化技巧，打造高命中率、高稳定性、可维护可扩展的Skill，规避常见问题，借助AI高效完成全生命周期管理。

## 一、Skill的定义与常见认知误区
### 1. 核心定义
Skill是一份**清晰、严谨、可执行的指令文档**，明确告知模型：在什么条件下（When）、按哪些步骤（How）、产出什么结果（What），是可长期复用、输入输出明确的能力模块。

### 2. 三大常见误区（正反示例对比）
| 误区类型 | 错误认知/做法 | 正确认知/做法 | 核心差异 |
|----------|---------------|---------------|----------|
| 误区一：Skill=Prompt | 将Skill写成一次性对话提示（如“帮我分析下这段代码”） | 设计可复用的能力模块（如`code-review` Skill，明确触发条件、执行步骤、输出格式） | Prompt偏向临时探索，Skill强调稳定复用与工程化维护 |
| 误区二：Skill是写给人看的文档 | 文档中包含大量原理解释、背景铺垫（如“因为代码评审需要关注安全性，所以我们先看漏洞”） | 使用模型可解析的结构化语言，仅下达指令（如“代码评审步骤：1. 检查安全性漏洞；2. 验证逻辑正确性”） | 核心目标是“让模型执行”，而非“让人理解” |
| 误区三：越复杂越强大 | 一个Skill包含“运行测试+更新PR状态+发送通知+lint校验”多个功能 | 拆分单一职责Skill（`running-unit-tests`/`updating-pr-status`/`sending-notification`） | 复杂度升高会增加模型决策成本，降低触发命中率 |

> 关键提示：模型上下文窗口有限，Skill需以“最小必要信息”为目标，避免冗余内容。

## 二、Skill的设计标准与核心原则
### 1. 元数据规范（name/description）
元数据是模型识别Skill的入口，直接影响触发准确率。

| 元数据字段 | 设计规范 | 正确示例 | 错误示例 |
|------------|----------|----------|----------|
| name | 简洁唯一、小写字母+数字+连字符、动名词形式、≤64字符 | running-tests、deploy-microservice | test-helper（语义模糊）、data-skill-v2（冗余版本）、deployService（命名不规范） |
| description | 第三人称（模型视角）、含核心功能+触发时机、≤1024字符 | "Review code for quality, correctness, and maintainability. Use when evaluating pull requests, refactoring existing code, or when the user asks for feedback on implementation details." | "I can help you review code"（第一人称）、"Helps with code review"（缺触发时机） |

### 2. 指导方式的自由度分级
根据任务复杂度与容错要求，控制对模型的约束强度。

| 自由度等级 | 适用场景 | 指导方式 | 示例（Skill片段） |
|------------|----------|----------|------------------|
| 高 | 多种有效方法、依赖上下文决策 | 提供启发式策略（给原则） | name: code-review<br>description: 当用户需要对代码进行审核时，基于代码实现与通用开发规范，分析逻辑正确性、可维护性和潜在风险，并给出改进建议。<br>指导原则：先看安全性，再看可读性 |
| 中 | 存在首选模式、行为受配置影响 | 提供模板/伪代码（给框架） | name: report-generator<br>description: 当用户需要生成报告时，按固定结构整理信息。<br>template:<br>摘要：- 简要概述核心信息<br>分析：- 详细拆解背景与原因<br>建议：- 提出具体改进方案 |
| 低 | 操作脆弱易错、需严格遵循序列 | 提供可执行脚本（给代码） | name: database-migration<br>description: 执行数据库迁移时，按预定义顺序执行脚本。<br>steps:<br>1. 备份数据库 → 2. 执行001_create_users_table.sql → 3. 执行002_add_email_index.sql → 4. 验证数据完整性 |

### 3. 五大核心设计标准（正反示例对比）
| 核心标准 | 要求描述 | 正确示例 | 错误示例 |
|----------|----------|----------|----------|
| 边界清晰 | 明确“使用场景”与“禁用场景” | Use this skill when:<br>- PR状态为“待合并”，需执行单元测试<br>- 用户意图触发CI/CD流水线<br>Do NOT use when:<br>- 用户仅查看测试报告<br>- PR仅修改文档/注释 | 模糊描述：“用户需要测试时使用” |
| 输入输出结构化 | 类似函数签名，明确字段类型与含义 | Input:<br>- prId: string（PR编号）<br>- branch: string（分支名称）<br>- runTests: boolean（是否执行测试）<br>Output:<br>- success: boolean（执行结果）<br>- testReport?: object[]（可选测试报告）<br>- errorMessage?: string（可选错误信息） | 模糊描述：“帮用户跑测试并返回结果” |
| 步骤明确可执行 | 指令式具体动作，而非概括性描述 | Steps:<br>1. Validate PR：检查prId和branch有效性<br>2. Checkout branch：切换到指定分支<br>3. Run tests：按参数执行单元测试<br>4. Collect results：收集测试结果<br>5. Update PR status：回写状态 | 描述性语言：“检查PR，运行测试，然后更新状态” |
| 失败策略完备 | 明确定义不同失败场景的处理方式 | On Failure:<br>- Validation fails：返回400错误+具体原因<br>- Test execution fails：自动重试1次，失败则返回“单元测试未通过，请检查日志”<br>- CI/CD服务不可用：最多重试3次，失败则通知管理员 | 未定义失败处理，让模型自由发挥 |
| 单一职责 | 一个Skill对应一个核心动作，避免功能捆绑 | 拆分Skill：<br>- running-unit-tests（仅执行单元测试）<br>- updating-pr-status（仅更新PR状态）<br>- running-lint-check（仅执行lint校验） | 一个Skill包含“运行测试+更新状态+发送通知+lint校验” |

## 三、Skill构建与迭代的最佳流程（评测驱动+失败优先）
Skill开发是“以失败为起点、评测为牵引”的持续迭代过程，共6步：

### 1. 建立无Skill基线，识别真实问题
- 不使用Skill，让模型直接执行目标任务，记录：
  - 表现不稳定、结果不可复现的场景；
  - 引发歧义、误解的输入；
  - 模型误触发“主动帮忙”的情况。
- 这些“失败点”就是Skill需解决的核心问题。

### 2. 定义评测用例（优先于开发Skill）
- 针对已识别的问题，设计3-5个可复现用例，明确“通过/失败”标准；
- 重点覆盖模型易误用Skill的场景（如边界场景、异常输入）。
- 示例：用例1（通过）：PR状态为“待合并”+含代码改动→触发`running-unit-tests`；用例2（失败）：PR仅修改文档→Skill拒绝执行。

### 3. 编写最小化Skill，明确最短成功路径
- 仅编写“刚好通过当前评测”的最小规则集合，不追求全覆盖；
- 核心动作：明确失败条件（When NOT to use）、定义最简执行流程、保持单一职责。

### 4. 补充边界条件与结构化示例
- 扩展适用范围：补充更多边界场景约束；
- 标准化输入输出：明确结构化定义；
- 添加示例：提供关键输入/输出示例，对齐模型预期。
- 原则：新增规则必须对应评测用例，不盲目复杂化。

### 5. 评测回归与持续迭代
- 新增用例→增量修改Skill；
- 修改Skill→必须通过已有评测回归验证；
- 评测未通过→优先简化Skill，而非叠加新规则。

### 6. 结合真实使用路径校准
- 观察真实场景中的问题：误触发、遗漏上下文、隐性依赖；
- 将新问题转化为评测用例，重新进入“定义评测用例”环节，形成闭环。

## 四、让Skill可维护、可扩展的关键技巧
### 1. 渐进式披露（减轻模型加载负担）
- 核心思想：SKILL.md作为“入口导航”，详细内容拆分至独立文件，按需加载；
- 规范：
  - SKILL.md主体≤500行，仅含必要信息；
  - 引用文件保持一层深度（避免A→B→C的链式引用）；
  - 长参考文件（＞100行）添加目录。
- 示例（SKILL.md）：
```markdown
# SKILL.md
## 基础用法
描述如何触发CI/CD流水线：
- 检查PR状态
- 执行单元测试
- 更新PR测试状态

## 高级功能
详细说明请参见 `ci-advanced-features.md`：
- 并行执行多分支测试
- 条件触发不同类型的测试

## API参考
所有方法与参数说明请参见 `ci-api-reference.md`：
- startPipeline(prId: string, branch: string)
- getPipelineStatus(pipelineId: string)
```

### 2. 工作流与反馈闭环（降低遗漏/跑偏风险）
工作流约束执行顺序，检查清单追踪状态，关键节点设置“验证→修正→再验证”闭环。

#### （1）分析类任务示例（技术方案评估）
```markdown
## 技术方案评估工作流
执行前复制清单，每步完成后标记状态：
- Step 1：明确业务目标与技术约束（性能、成本、时限）→ □ 完成
- Step 2：列出所有可行的技术方案 → □ 完成
- Step 3：从复杂度、可维护性、风险角度逐一评估 → □ 完成
- Step 4：对比关键差异点（反馈闭环：信息不足则返回Step 2/3）→ □ 完成
- Step 5：给出结论性建议（反馈闭环：结论不满足约束则重新审视Step 1）→ □ 完成
```

#### （2）代码类任务示例（依赖版本升级）
```markdown
## 依赖版本升级工作流
- Step 1（Plan）：识别待升级依赖及当前版本 → 阅读目标版本Release Notes
- Step 2（Plan）：更新依赖配置文件 → 标注受影响模块
- Step 3（Validate）：执行依赖冲突检查（运行dependency_check.sh）→ 无冲突则继续（冲突则回退Step 2）
- Step 4（Execute）：安装新版本依赖 → 运行完整测试集
- Step 5（Validate）：检查核心功能 → 对比升级前后结果（异常则回滚并记录风险）
```

### 3. 可执行脚本的加固原则（失败可预期、输出可理解）
| 加固要点 | 正确示例 | 错误示例 |
|----------|----------|----------|
| 显式处理错误 | ERROR: Config file not found: ./deploy.yaml<br>HINT: 检查文件路径或执行init-config.sh生成默认配置 | 直接抛出异常：FileNotFoundError: [Errno 2] No such file or directory |
| 输出自解释日志 | CHECK FAILED: Node.js version mismatch<br>- Required: ≥18.0.0<br>- Detected: 16.14.0<br>VALID OPTIONS:<br>1. 升级Node.js至支持版本<br>2. 切换兼容的构建镜像 | 仅输出：Node.js版本错误 |
| 避免魔法数字 | TIMEOUT_SECONDS = 30 # 服务启动通常需10-20秒，预留冗余时间 | TIMEOUT_SECONDS = 30（无解释） |

## 五、借助AI高效创建与迭代Skill
### 1. 初次创建（从具体任务抽象）
1. 让AI直接执行真实任务（如“帮我评审这段Java代码”），记录执行中的追问、走偏与修正（隐式评测）；
2. 引导AI复盘：成功步骤、失败点、固定流程、适用/不适用场景；
3. 要求AI按Skill规范生成SKILL.md初稿（明确When/How/What/失败策略）；
4. 人工评审边界合理性与步骤可执行性，确认后入库。

### 2. 持续迭代（从使用反馈优化）
1. 针对Skill使用中暴露的新问题，引导AI分析偏差来源（When/How/What哪部分需调整）；
2. AI更新SKILL.md并验证：不破坏原有成功路径、覆盖新错误场景；
3. 回归评测用例，确认优化效果。

## 六、反模式检查清单（规避典型问题）
| 反模式 | 问题原因 | 正确示例 | 错误示例 |
|--------|----------|----------|----------|
| 使用Windows风格路径 | 跨平台兼容性差（Unix/Linux报错） | configs/deploy.yaml | configs\deploy.yaml |
| 提供过多选择 | 增加模型决策成本，易困惑 | “默认使用PostgreSQL（常规生产/测试环境），仅兼容性要求特殊时用MySQL” | “你可以用PostgreSQL、MySQL、SQLite、Oracle...” |
| 包含时效性信息 | 信息易过期，导致Skill失效 | 将旧版本配置放入deprecated/文件夹，标注“不再推荐使用” | “2025年8月前用旧API，之后用新API” |
| 术语不一致 | 增加模型理解成本，降低可用性 | 统一使用“Service Endpoint” | 混用“Service Endpoint”“API URL”“Endpoint Path” |

## 核心总结
Skill设计与开发的核心是“**评测驱动、简洁明确、闭环迭代**”：
1. 明确边界与目标，避免功能冗余和认知误区；
2. 按“元数据规范+结构化输入输出+明确步骤+失败策略”打造高稳定性Skill；
3. 以评测用例为约束，从失败点出发，持续迭代优化；
4. 通过渐进式披露、工作流闭环、脚本加固提升可维护性；
5. 借助AI降低创建与迭代成本，聚焦问题定义与结果验收。