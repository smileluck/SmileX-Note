

# 目录结构

## 适合新手
```
lib/
  ├── app/                # 应用全局配置
  │   ├── app.dart        # 主应用入口
  │   └── app_routes.dart # 路由配置
  │
  ├── features/           # 功能模块（核心结构）
  │   ├── auth/           # 认证模块
  │   │   ├── bloc/       # 状态管理（如 Bloc/Cubit）
  │   │   ├── repository/ # 数据仓库
  │   │   ├── screens/    # 页面组件
  │   │   ├── widgets/    # 复用组件
  │   │   └── auth.dart   # 模块入口
  │   │
  │   ├── home/           # 首页模块
  │   ├── profile/        # 个人信息模块
  │   └── ...             # 其他模块
  │
  ├── common/             # 通用功能
  │   ├── widgets/        # 全局复用组件
  │   ├── utils/          # 工具函数
  │   ├── constants/      # 常量定义
  │   └── extensions/     # 扩展方法
  │
  └── data/               # 数据层
      ├── models/         # 数据模型
      ├── datasources/    # 数据源（本地/远程）
      └── repositories/   # 仓库实现
```
优点：
- 清晰分离功能模块，易于查找和维护
- 适合中大型项目和团队协作
- 可扩展性强，新增功能只需添加新模块
适用场景：
- 大多数 Flutter 应用（推荐采用）

## 按分层架构划分（MVVM/BLoC 等）
```
lib/
  ├── presentation/       # 表现层
  │   ├── screens/        # 页面
  │   ├── widgets/        # 组件
  │   └── viewmodels/     # 视图模型（MVVM）或 Bloc
  │
  ├── domain/             # 领域层（业务逻辑）
  │   ├── entities/       # 实体类
  │   ├── repositories/   # 抽象仓库接口
  │   └── usecases/       # 用例（业务逻辑单元）
  │
  └── data/               # 数据层
      ├── datasources/    # 数据源
      ├── repositories/   # 仓库实现
      └── models/         # 数据模型
```

优点：
- 严格遵循单一职责原则
- 便于单元测试和独立开发各层
- 适合复杂业务逻辑的企业级应用
缺点：
- 初期学习成本较高
- 小型项目可能过度设计
- 适用场景：
- 大型项目、需要严格测试的应用

# 状态管理
> https://docs.flutter.cn/data-and-backend/state-mgmt/options

Flutter开发中，状态管理至关重要，市面上流行的状态管理方式各有千秋。综合文档及相关资料，目前流行的方式有Provider、Riverpod、BLoC、GetX、Redux等，它们在不同场景下展现出独特的优势与不足。
1. **Provider**
    - **优点**：官方推荐，生态良好，资料丰富，在StackOverflow等平台容易找到相关问题的答案；基于InheritedWidget封装，能方便地在Widget树中自上而下共享数据，实现状态共享；对于跨组件共享状态的管理较为简单，无需复杂操作；当共享数据变化时，能自动通知依赖该数据的组件进行刷新 ，业务代码专注数据更新，UI自动更新，无需手动调用setState()。在大型复杂应用中，可简化代码逻辑，降低出错概率，提高开发效率。
    - **缺点**：在处理复杂业务逻辑时，可能会使代码结构变得复杂，尤其是当状态管理逻辑交织时，维护难度会增加；虽然能实现状态共享，但对于非常复杂的状态变化监听和处理，不够灵活和直观。
2. **Riverpod**
    - **优点**：由Provider作者开发，且被Flutter官方推荐，安全性高，在编译代码前就能告知开发者可能遇到的问题；具有出色的文档和专门的网站，提供丰富的使用方法和示例；内置状态通知器，提供了不可变的方式控制状态，便于管理和维护。
    - **缺点**：相对较新，对于一些习惯旧有状态管理方式的开发者，学习成本可能较高；虽然功能强大，但在简单应用中使用，可能会引入过多不必要的复杂性。
3. **BLoC（Business Logic Component）**
    - **优点**：基于响应式编程，使用流来管理事件和状态，能很好地分离业务逻辑与UI，使代码结构清晰，易于维护；在处理复杂、异步操作时效率高，适合大型复杂应用，能方便地管理共享状态；状态变化可独立测试，便于发现和解决问题。
    - **缺点**：学习成本较高，需要开发者理解流的概念和响应式编程思想；代码量相对较大，需要定义事件、状态和Bloc类等，增加了开发的工作量；对于简单应用来说，使用BLoC可能会过度设计，增加不必要的复杂性。
4. **GetX**
    - **优点**：功能丰富，集状态管理、路由管理和依赖管理于一体，代码简洁，能大大提高开发效率；提供了简单的响应式状态管理解决方案，上手容易。
    - **缺点**：被部分Flutter专家认为会阻碍开发者了解Flutter真正的开发内容，其功能的大而全可能导致代码逻辑不够清晰，对于大型项目的可维护性存在一定挑战；由于功能集成度高，可能会引入一些不必要的依赖，增加应用的体积。
5. **Redux**
    - **优点**：前端开发者较为熟悉，有成熟的理念和模式；单向数据流使得状态管理可预测，易于理解和调试；适合大型应用的状态管理，能够很好地管理复杂的应用状态。
    - **缺点**：引入了较多的概念和样板代码，如action、reducer等，增加了学习成本和开发的复杂性；在处理异步操作时，需要额外的中间件（如redux - thunk、redux - saga），配置和使用相对复杂。 